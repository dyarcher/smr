// Dylan Archer Dingwell
// SMR is a magnetic resonance model compatible with the Smoldyn biochemical simulation platform.
// smr.cpp contains core code for SMR. Shared global variables created here are defined as externs in the Smoldyn header file.

#include <iostream>
#include <fstream>
#include <cmath>
#include <vector>
#include <string>
#include <string.h>
#include <sstream>
#include <iterator>
//#include <omp.h>

#include "smoldyn.h"                    // Smoldyn header
#include "smoldynfuncs.h"               // Smoldyn functions header
#include "smoldynconfigure.h"			// Smoldyn configuration header, generated by CMake from smoldynconfigure.h.in

// initialization parameters
bool smrinit = false;
char *seqfilename; // name of sequence file
char *seqtypetok; // "discrete" for scanner discrete timecourse, "pulseq" for pulseq format; set by smrparseq command
std::string seqtype; // "discrete" for scanner discrete timecourse, "pulseq" for pulseq format; set by smrparseq command
int seqchunk = 1000; // number of timepoints to read into arrays at once from discrete sequence files
int seqchunk_idx = 0;
int seqchunks_used = 0;
int lines_read = 1;
std::string ro_filename;

// debug prints all simulated outputs
bool smrdebug = false;
bool smrdebug_new = false;
std::ofstream debugfile;
std::ofstream outputfile;
int debugsamplefactor = 100; // how often to write info; will write every n timesteps
int debug_idx = 0;

// option to calculate k-space
bool calckspace = false;
std::ofstream kspacefile;
double kx = 0.;
double ky = 0.;
double kz = 0.;
int kspacesamplefactor = 100; // how often to write info; will write every n timesteps
int kspace_idx = 0;

// input parameters
double samplingtime = 1e-6;

// work variables
std::vector<double> smrT1s;
std::vector<double> smrT2s;
std::vector<double> smrGyros;
std::vector<double> smrCSs;
std::vector<double> smrHPT1s;
std::vector<double> smrBasePols;
std::vector<smrblockptr> smrblocks;
double ro_mx = 0.;
double ro_my = 0.;
double ro_mz = 0.;
double ro_rfp = 0.;
double stored_rfp = 0.;
int curr_time_idx_rf = 0;
int curr_time_idx_rfn = 0;
int curr_time_idx_rfp = 0;
int curr_time_idx_gx = 0;
int curr_time_idx_gy = 0;
int curr_time_idx_gz = 0;
int curr_time_idx_adc = 0;
std::vector<std::string> pulseq;
std::vector<std::vector<int>> blocks;
std::vector<std::vector<double>> delays;
std::vector<std::vector<double>> rfs;
std::vector<std::vector<double>> gradients;
std::vector<std::vector<double>> traps;
std::vector<std::vector<double>> adcs;
std::vector<std::vector<double>> shapes;
std::vector<double> rf_time;
std::vector<double> rf_amp;
std::vector<double> rfneg_time;
std::vector<double> rfneg_amp;
std::vector<double> rfp_time;
std::vector<double> rfp_amp;
std::vector<double> gx_time;
std::vector<double> gx_amp;
std::vector<double> gy_time;
std::vector<double> gy_amp;
std::vector<double> gz_time;
std::vector<double> gz_amp;
std::vector<double> adc_time;
std::vector<double> adc_amp;
std::vector<std::vector<double>> readout_values;
std::vector<double> adc_timings;
std::vector<double> relaxing_times;
int idx_adc = 0;

// module initialization
bool smr_init() {
	if (!smrinit) {
		std::cout << std::endl << "Smoldyn MR Module (SMR) Initialized" << std::endl;
		smrinit = true;
	}
	return true;
}

// runtime command processing
// set quality control/monitoring/debugging parameters
void smrinfo(char* line2) {
	smr_init();
	// parse command line
	const char s[2] = " ";
	char *token;
	token = strtok(line2, s);
	char *filename;
	char *infotype;
	int samplefactor;
	int i = 0;
	while (token != NULL) {
		if (i == 0) { // file to write
			filename = token;
		} else if (i == 1) { // info type
			infotype = token;
		} else if (i == 2) {
			samplefactor = strtol(token, NULL, 10);
		}
		token = strtok(NULL, s);
		i += 1;
	}
	if (strcmp(infotype, "debug") == 00) { // debug info
		smrdebug_new = true;
		std::cout << "- Debugging information will be written to: " << filename << std::endl;
		debugfile.open(filename);
		debugsamplefactor = samplefactor;
	} else if ((strcmp(infotype, "ktraj") == 0) | (strcmp(infotype, "kspace") == 0)) { // calculate k-space
		calckspace = true;
		std::cout << "- k-space trajectory will be written to: " << filename << std::endl;
		kspacefile.open(filename);
		kspacesamplefactor = samplefactor;
	}
}

// output info
void smroutput(char* line2) {
	const char s[2] = " ";
	char *token;
	token = strtok(line2, s);
	int species = 0;
	char *fname;
	int i = 0;
	while (token != NULL) {
		if (i == 0) { // filename
			fname = token;
		} else if (i == 1) { // species to write
			species = std::stoi(token);
		}
		token = strtok(NULL, s);
		i += 1;
	}
	int popcount = 0;
	double xmag = 0.;
	double ymag = 0.;
	double zmag = 0.;
	i = 0;
	for (i = 0; i < smrblocks.size(); i++) {
		if (smrblocks[i].spinspecies == species) {
			popcount += 1;
			xmag += smrblocks[i].Mx; // add x-magnetization to total
			ymag += smrblocks[i].My; // add y-magnetization to total
			zmag += smrblocks[i].Mz; // add z-magnetization to total
		}
	}
	if (!outputfile.is_open()) {
		outputfile.open(fname);
	}
	outputfile << species << " ";
	outputfile << popcount << " ";
	outputfile << xmag << " ";
	outputfile << ymag << " ";
	outputfile << zmag << "\n";
}

// set MR parameters
void smrsetMR(char* line2) {
	// parse command line
	const char s[2] = " ";
	char *token;
	token = strtok(line2, s);
	int i = 0;
	while (token != NULL) {
		if (i == 0) { // gyromagnetic ratio
			smrGyros.push_back(std::stod(token)*6.28318530718e6);
		} else if (i == 1) { // chemical shift
			smrCSs.push_back(std::stod(token)*6.28318530718/3);
		} else if (i == 2) { // T1
			smrT1s.push_back(std::stod(token));
		} else if (i == 3) { // T2
			smrT2s.push_back(std::stod(token));
		}
		token = strtok(NULL, s);
		i += 1;
	}
}
// set HPMR parameters
void smrsetHPMR(char* line2) {
	// parse command line
	const char s[2] = " ";
	char *token;
	token = strtok(line2, s);
	int i = 0;
	while (token != NULL) {
		if (i == 0) { // hyperpolarization factor
			smrBasePols.push_back(std::stod(token));
			relaxing_times.push_back(0.);
		} else if (i == 1) { // relaxation time of hyperpolarized magnetization
			smrHPT1s.push_back(std::stod(token));
		}
		token = strtok(NULL, s);
		i += 1;
	}
}

// helper functions

// vector magnitude
double vecmag(double v0, double v1, double v2)
{
	double base = pow(v0,2) + pow(v1,2) + pow(v2,2);
	return sqrt(base);
}

// Hamilton products for quaternion rotation calculation
double hp0(double q0, double q1, double q2, double q3, double p0, double p1, double p2, double p3)
{
	return q0*p0 - q1*p1 - q2*p2 - q3*p3;
}
double hp1(double q0, double q1, double q2, double q3, double p0, double p1, double p2, double p3)
{
	return q0*p1 + q1*p0 + q2*p3 - q3*p2;
}
double hp2(double q0, double q1, double q2, double q3, double p0, double p1, double p2, double p3)
{
	return q0*p2 - q1*p3 + q2*p0 + q3*p1;
}
double hp3(double q0, double q1, double q2, double q3, double p0, double p1, double p2, double p3)
{
	return q0*p3 + q1*p2 - q2*p1 + q3*p0;
}

// Bloch simulator functions
// rotquat: rotate M vector around B vector
void rotquat(double gamma, double tau, double &mx, double &my, double &mz, double &bx, double &by, double &bz)
{
	double Bmag = vecmag(bx, by, bz);
	double rotangle = gamma * Bmag * tau;
	double bux = bx/Bmag;
	double buy = by/Bmag;
	double buz = bz/Bmag;
	double q0 = cos(rotangle/2);
	double q1 = sin(rotangle/2) * bux;
	double q2 = sin(rotangle/2) * buy;
	double q3 = sin(rotangle/2) * buz;
	double p0 = hp0(q0, q1, q2, q3, 0.0, mx, my, mz);
	double p1 = hp1(q0, q1, q2, q3, 0.0, mx, my, mz);
	double p2 = hp2(q0, q1, q2, q3, 0.0, mx, my, mz);
	double p3 = hp3(q0, q1, q2, q3, 0.0, mx, my, mz);
	mx = hp1(p0, p1, p2, p3, q0, -q1, -q2, -q3);
	my = hp2(p0, p1, p2, p3, q0, -q1, -q2, -q3);
	mz = hp3(p0, p1, p2, p3, q0, -q1, -q2, -q3);
}

// rotquat_hardangle: rotation around a fixed angle
void rotquat_hardangle(double rotangle, double &mx, double &my, double &mz)
{
	double q0 = cos(rotangle/2);
	double q1 = 0.0;
	double q2 = 0.0;
	double q3 = sin(rotangle/2);
	double p0 = hp0(q0, q1, q2, q3, 0.0, mx, my, mz);
	double p1 = hp1(q0, q1, q2, q3, 0.0, mx, my, mz);
	double p2 = hp2(q0, q1, q2, q3, 0.0, mx, my, mz);
	double p3 = hp3(q0, q1, q2, q3, 0.0, mx, my, mz);
	mx = hp1(p0, p1, p2, p3, q0, -q1, -q2, -q3);
	my = hp2(p0, p1, p2, p3, q0, -q1, -q2, -q3);
	mz = hp3(p0, p1, p2, p3, q0, -q1, -q2, -q3);
}

// smr_relax: relax magnetization
void smr_relax(double tau, double T1, double T2, double HPT1, double M0, double &mx, double &my, double &mz, double relaxing_time)
{
	mx *= exp(-tau/T2);
	my *= exp(-tau/T2);
	if (abs(mz) < 1) mz = M0 + (1-exp(-relaxing_time/T1));
	if (HPT1 > 1e-12){
		if (pow(mx,2)+pow(my,2) > 1) {
			mx *= exp(-tau/HPT1);
			my *= exp(-tau/HPT1);
		}
		if (abs(mz) > 1) mz *= exp(-tau/HPT1);
	}
}

// get_T1: get T1 value from current position
double get_T1(double posx, double posy, double posz, int spinspecies) {
	return smrT1s[spinspecies-1];
}
// get_T2: get T2 value from current position
double get_T2(double posx, double posy, double posz, int spinspecies) {
	return smrT2s[spinspecies-1];
}
// get_HPT1: get hyperpolarized T1 value from species
double get_HPT1(int spinspecies) {
	return smrHPT1s[spinspecies-1];
}
// get_BasePol: get base polarization value from species
double get_BasePol(int spinspecies) {
	return smrBasePols[spinspecies-1];
}
// read_adc: read in adc values from separate file
void read_adc(char *filename)
{
	// read in adc file
	std::ifstream adcfile;
    adcfile.open(filename);
	std::string line; // stores text line as string
	//adc_timings.resize(0); // clear ADC timings from pulse file, if any were provided; explicit smrreadadc command takes precedence
	while (std::getline(adcfile, line)) {
		if (line.length() > 0) {
			adc_timings.push_back(std::stod(line));
		}
	}
	adcfile.close();
}

// sequence parsing functions
// discrete timecourse sequence parser
void use_discseq(std::ifstream &seqfile, int chunk, int chunks_used, std::vector<double> &rf_time, std::vector<double> &rf_amp, std::vector<double> &rfneg_time, std::vector<double> &rfneg_amp, std::vector<double> &gx_time, std::vector<double> &gx_amp, std::vector<double> &gy_time, std::vector<double> &gy_amp, std::vector<double> &gz_time, std::vector<double> &gz_amp, std::vector<double> &adc_time, std::vector<double> &adc_amp)
{
	std::string line; // stores text line as string
	for (int n = 0; n < chunk*chunks_used; n += 1) {
		if (!std::getline(seqfile, line)) {
			// Error or premature end of file! Handle appropriately.
		}
	}

	while (std::getline(seqfile, line)) {
		std::string paramval = "";
		double t = 0.;
		int i = 0;
		for (char& c : line) {
			if (!isspace(c)) {
				paramval.push_back(c);
			} else if (paramval != "") {
				if (i == 0) {
					t = std::stod(paramval);
					rf_time.push_back(std::stod(paramval));
					rfneg_time.push_back(std::stod(paramval));
					gx_time.push_back(std::stod(paramval));
					gy_time.push_back(std::stod(paramval));
					gz_time.push_back(std::stod(paramval));
					adc_time.push_back(std::stod(paramval));
				} else if (i == 1) {
					rf_amp.push_back(std::stod(paramval));
					rfneg_amp.push_back(1.00000000); // needs update for proper phase correction
				} else if (i == 2) {
					gx_amp.push_back(std::stod(paramval));
				} else if (i == 3) {
					gy_amp.push_back(std::stod(paramval));
				} else if (i == 4) { // not currently used
					gz_amp.push_back(std::stod(paramval));
					adc_amp.push_back(0.0);
				} else if (i == 5) {
					//adc_amp.push_back(std::stod(paramval));
				}
				paramval = "";
				i += 1;
			}
		}
		gz_amp.push_back(std::stod(paramval)); // needed here because i=4 is never reached currently
		adc_amp.push_back(0.0);
	}
}

// pulseq parser
void read_pulseq(std::ifstream &seqfile, std::vector<std::vector<int>> &blocks, std::vector<std::vector<double>> &delays, std::vector<std::vector<double>> &rfs, std::vector<std::vector<double>> &gradients,  std::vector<std::vector<double>> &traps, std::vector<std::vector<double>> &adcs, std::vector<std::vector<double>> &shapes)
{
    std::string line; // stores text line as string
	std::string seqsect; // pulseq file section header
	std::vector<int> block;
	std::vector<double> delay;
	std::vector<double> rf;
	std::vector<double> gradient;
	std::vector<double> trap;
	std::vector<double> adc;
	std::vector<double> shape;
	int shape_id = -1;
	
    // loop through the text file line-by-line
    while (std::getline(seqfile, line)) {
		// skip blank lines
        if (line.length() == 0) {
			if (seqsect != "SHAPES" ) {
				seqsect = "HEADERS";
			}
            continue;
        }
		
		// determine current section of seq file
		if (line.find("[DEFINITIONS]") != std::string::npos) {
			seqsect = "DEFINITIONS";
			continue;
		}
		if (line.find("[BLOCKS]") != std::string::npos) {
			seqsect = "BLOCKS";
			continue;
		}
		if (line.find("[RF]") != std::string::npos) {
			seqsect = "RF";
			continue;
		}
		if (line.find("[GRADIENTS]") != std::string::npos) {
			seqsect = "GRADIENTS";
			continue;
		}
		if (line.find("[TRAP]") != std::string::npos) {
			seqsect = "TRAPS";
			continue;
		}
		if (line.find("[DELAYS]") != std::string::npos) {
			seqsect = "DELAYS";
			continue;
		}
		if (line.find("[ADC]") != std::string::npos) {
			seqsect = "ADC";
			continue;
		}
		if (line.find("[SHAPES]") != std::string::npos) {
			seqsect = "SHAPES";
			continue;
		}
		
		// section-specific actions
		
		// blocks
		if (seqsect == "BLOCKS") {
			std::string paramval = "";
			for (char& c : line) {
				if (!isspace(c)) {
					paramval.push_back(c);
				} else if (paramval != "") {
					block.push_back(std::stoi(paramval));
					paramval = "";
				}
            }
			if (paramval != "") {
				block.push_back(std::stoi(paramval));
			}
			blocks.push_back(block);
			block.resize(0);
			continue;
        }
		
		// delays
		if (seqsect == "DELAYS") {
			std::string paramval = "";
			for (char& c : line) {
				if (!isspace(c)) {
					paramval.push_back(c);
				} else if (paramval != "") {
					delay.push_back(std::stoi(paramval));
					paramval = "";
				}
            }
			if (paramval != "") {
				delay.push_back(std::stoi(paramval));
			}
			delays.push_back(delay);
			delay.resize(0);
			continue;
        }
		
		// rf
		if (seqsect == "RF") {
			std::string paramval = "";
			for (char& c : line) {
				if (!isspace(c)) {
					paramval.push_back(c);
				} else if (paramval != "") {
					rf.push_back(std::stod(paramval));
					paramval = "";
				}
            }
			if (paramval != "") {
				rf.push_back(std::stod(paramval));
			}
			rfs.push_back(rf);
			rf.resize(0);
			continue;
		}
		
		// arbitrary gradients
		if (seqsect == "GRADIENTS") {
			std::string paramval = "";
			for (char& c : line) {
				if (!isspace(c)) {
					paramval.push_back(c);
				} else if (paramval != "") {
					gradient.push_back(std::stod(paramval));
					paramval = "";
				}
            }
			if (paramval != "") {
				gradient.push_back(std::stod(paramval));
			}
			gradients.push_back(gradient);
			gradient.resize(0);
			continue;
		}
		
		// trapezoidal gradients
		if (seqsect == "TRAPS") {
			std::string paramval = "";
			for (char& c : line) {
				if (!isspace(c)) {
					paramval.push_back(c);
				} else if (paramval != "") {
					trap.push_back(std::stod(paramval));
					paramval = "";
				}
            }
			if (paramval != "") {
				trap.push_back(std::stod(paramval));
			}
			traps.push_back(trap);
			trap.resize(0);
			continue;
		}
		
		// adc
		if (seqsect == "ADC") {
			std::string paramval = "";
			for (char& c : line) {
				if (!isspace(c)) {
					paramval.push_back(c);
				} else if (paramval != "") {
					adc.push_back(std::stod(paramval));
					paramval = "";
				}
            }
			if (paramval != "") {
				adc.push_back(std::stod(paramval));
			}
			adcs.push_back(adc);
			adc.resize(0);
			continue;
		}
		
		// shapes
		if (seqsect == "SHAPES") {
			if (line.find("shape_id") != std::string::npos) {
				if (shape_id > -1 ) {
					shapes.push_back(shape);
				}
				shape.resize(0);
				shape_id += 1;
				continue;
			}
			if (line.find("num_samples") != std::string::npos) {
				shape.push_back(std::stod(line.substr(12)));
				continue;
			}
			shape.push_back(std::stod(line));
			continue;
		}
    }
	shapes.push_back(shape);
	shape.resize(0);
}

void parse_shape_rf(double samplingtime, double maxamp, double delay, std::vector<double> shape, std::vector<double> &tctimes, std::vector<double> &tcamps, double &seqtime, bool is_phase)
{
	double currtime = seqtime*1.0;
	double curramp = 0;
	tctimes.push_back(currtime);
	tcamps.push_back(curramp);
	currtime += delay;
	tctimes.push_back(currtime);
	tcamps.push_back(curramp);
	double delta = 0;
	std::vector<double>::iterator sample;
	int i = 1;
	for (sample = shape.begin()+1; sample < shape.end(); sample++) {
		if (is_phase) {
			if ((abs(*sample) > 0) & (abs(*sample) < 1)) {
				currtime += samplingtime;
				curramp = *sample;
			} else if ((int)(*sample) == 0) {
				currtime += samplingtime;
			} else {
				currtime += (*sample)*samplingtime;
			}
			tctimes.push_back(currtime);
			tcamps.push_back(curramp);
		} else {
			if ((abs(*sample) > 0) & (abs(*sample) < 1)) {
				delta = *sample;
				currtime += samplingtime;
				curramp += delta*maxamp;
			} else if ((i > 1) & ((int)(*sample) == 0) & (shape[i-2] != shape[i-1])) {
				delta = *sample;
				currtime += samplingtime;
				curramp = 0;
			} else {
				currtime += (*sample)*samplingtime;
				curramp += (*sample)*delta*maxamp;
			}
			tctimes.push_back(currtime);
			tcamps.push_back(curramp);
		}
		i++;
	}
}

void parse_shape_rfp(double samplingtime, double phase, double delay, std::vector<double> shape, std::vector<double> &tctimes, std::vector<double> &tcamps, double &seqtime, bool is_phase)
{
	double currtime = seqtime*1.0;
	tctimes.push_back(currtime);
	tcamps.push_back(phase);
	currtime += delay;
	tctimes.push_back(currtime);
	tcamps.push_back(phase);
	double delta = 0;
	std::vector<double>::iterator sample;
	int i = 1;
	for (sample = shape.begin()+1; sample < shape.end(); sample++) {
		if ((abs(*sample) > 0) & (abs(*sample) < 1)) {
			delta = *sample;
			currtime += samplingtime;
		} else if ((i > 1) & ((int)(*sample) == 0) & (shape[i-2] != shape[i-1])) {
			delta = *sample;
			currtime += samplingtime;
		} else {
			currtime += (*sample)*samplingtime;
		}
		tctimes.push_back(currtime);
		tcamps.push_back(phase);
		i++;
	}
}

void parse_gradient(double samplingtime, std::vector<double> gline, std::vector<double> &tctimes, std::vector<double> &tcamps, double &seqtime)
{
	double gradsamplingtime = 10e-6;
	int samplespersample = (int)(gradsamplingtime/samplingtime);
	double currtime = seqtime*1.0;
	double curramp = 0;
	double maxamp = gline[1];
	std::vector<double> shape = shapes[(int)gline[2]-1];
	double delta = 0;
	std::vector<double>::iterator sample;
	int i = 1;
	for (sample = shape.begin()+1; sample < shape.end(); sample++) {
		// nonsense first and last samples that aren't in the specification
		if (i == 1) {
			if (abs(*sample) == 1) {
				curramp = (*sample)*maxamp;
				tctimes.push_back(currtime);
				tcamps.push_back(curramp);
				currtime += gline[3]*(1e-6);
				tctimes.push_back(currtime);
				tcamps.push_back(curramp);
				i++;
				continue;
			}
			tctimes.push_back(currtime);
			tcamps.push_back(curramp);
			currtime += gline[3]*(1e-6);
			tctimes.push_back(currtime);
			tcamps.push_back(curramp);
		} else if ((i == shape.size()) & (*sample == 0)) {
			break;
		}
		// actual parsing
		if (*sample == 0) {
			delta = 0;
			currtime += gradsamplingtime;
		} else if ((abs(*sample) > 0) & (abs(*sample) < 1)) {
			delta = *sample;
			int j = 0;
			while (j < samplespersample) {
				currtime += samplingtime;
				curramp += delta*maxamp/samplespersample;
				tctimes.push_back(currtime);
				tcamps.push_back(curramp);
				j++;
			}
		} else {
			int j = 0;
			while (j < (*sample)*samplespersample) {
				currtime += samplingtime;
				curramp += delta*maxamp/samplespersample;
				tctimes.push_back(currtime);
				tcamps.push_back(curramp);
				j++;
			}
		}
		i++;
	}
}

void parse_trap(double samplingtime, std::vector<double> gline, std::vector<double> &tctimes, std::vector<double> &tcamps, double &seqtime)
{
	double currtime = seqtime*1.0;
	double maxamp = gline[1];
	double risetime = gline[2]*(1e-6);
	double flattime = gline[3]*(1e-6);
	double falltime = gline[4]*(1e-6);
	double delay = gline[5]*(1e-6);
	double curramp = 0;
	tctimes.push_back(currtime);
	tcamps.push_back(curramp);
	currtime += delay;
	tctimes.push_back(currtime);
	tcamps.push_back(curramp);
	while (currtime < delay+risetime+seqtime) {
		currtime += samplingtime;
		curramp += maxamp/risetime*samplingtime;
		if (currtime > delay+risetime+seqtime | abs(curramp) > abs(maxamp)) {
			currtime = delay+risetime+seqtime;
			curramp = maxamp;
		}
		tctimes.push_back(currtime);
		tcamps.push_back(curramp);
	}
	curramp = maxamp;
	tctimes.push_back(currtime);
	tcamps.push_back(curramp);
	currtime += flattime;
	tctimes.push_back(currtime);
	tcamps.push_back(curramp);
	while (currtime < delay+risetime+flattime+falltime+seqtime) {
		currtime += samplingtime;
		curramp += -maxamp/falltime*samplingtime;
		if ((currtime > delay+risetime+flattime+falltime+seqtime) | (curramp < 0 & maxamp > 0) | ((curramp > 0) & (maxamp < 0))) {
			currtime = delay+risetime+flattime+falltime+seqtime;
			curramp = 0;
		}
		tctimes.push_back(currtime);
		tcamps.push_back(curramp);
	}
	tctimes.push_back(currtime);
	tcamps.push_back(curramp);
}

void parse_adc(double samplingtime, std::vector<double> aline, std::vector<double> &tctimes, std::vector<double> &tcamps, double &seqtime)
{
	double currtime = seqtime*1.0;
	double curramp = 0.0;
	double num_samples = aline[1];
	double dwelltime = aline[2]*(1e-9);
	double delay = aline[3]*(1e-6);
	tctimes.push_back(currtime);
	tcamps.push_back(curramp);
	currtime += delay;
	curramp = 0.0;
	tctimes.push_back(currtime);
	tcamps.push_back(curramp);
	while (currtime < seqtime+delay+(num_samples*dwelltime)) {
		currtime += samplingtime;
		curramp = 1.0;
		tctimes.push_back(currtime);
		tcamps.push_back(curramp);
	}
	currtime += samplingtime;
	curramp = 0.0;
	tctimes.push_back(currtime);
	tcamps.push_back(curramp);
}

void rf_amplitude_by_neg(std::vector<double> &rfneg_time, std::vector<double> &rfneg_amp, std::vector<double> &rf_time, std::vector<double> &rf_amp)
{
	int i = 0;
	int j = 0;
	int negfactor = 1;
	for (double d : rfneg_time) {
        if (abs(rfneg_amp[i]) > 0) {
			negfactor *= -1;
		}
		for (j = j; (j < rf_time.size()) & (rf_time[j] < d); j++) {
			rf_amp[j] *= negfactor;
		}
		i++;
    }
}

std::vector<double> gradient_by_id(double gradid, std::vector<std::vector<double>> &gradinfo)
{
	std::vector<double> gradient;
	if (gradinfo.size() > 0) {
		std::vector<std::vector<double>>::iterator grad;
		for (grad = gradinfo.begin(); grad < gradinfo.end(); grad++) {
			if ((*grad)[0] == gradid) {
				gradient = (*grad);
			}
		}
	}
	return gradient;
}


void gen_timecourse(double samplingtime, std::vector<std::vector<int>> &blocks, std::vector<std::vector<double>> &delays, std::vector<std::vector<double>> &rfs, std::vector<std::vector<double>> &traps, std::vector<std::vector<double>> &adcs, std::vector<std::vector<double>> &shapes, std::vector<double> &rf_time, std::vector<double> &rf_amp, std::vector<double> &rfneg_time, std::vector<double> &rfneg_amp, std::vector<double> &rfp_time, std::vector<double> &rfp_amp, std::vector<double> &gx_time, std::vector<double> &gx_amp, std::vector<double> &gy_time, std::vector<double> &gy_amp, std::vector<double> &gz_time, std::vector<double> &gz_amp, std::vector<double> &adc_time, std::vector<double> &adc_amp)
{
	// loop through blocks and generate timecourses
	std::vector<std::vector<int>>::iterator block;
	double seqtime = 0;
	for (block = blocks.begin(); block < blocks.end(); block++) {
		// rf
		if ((*block)[2] != 0) {
			std::vector<double> rfline = rfs[(*block)[2]-1];
			double rfdelay = rfline[4] * 1e-6;
			// rf phase
			double rfpmaxamp = rfline[6];
			std::vector<double> rfpshape = shapes[(int)rfline[3]-1];
			parse_shape_rfp(samplingtime, rfpmaxamp, rfdelay, rfpshape, rfp_time, rfp_amp, seqtime, true);
			// rf amplitude negativity
			double rfnegmaxamp = 1.0;
			parse_shape_rf(samplingtime, rfnegmaxamp, rfdelay, rfpshape, rfneg_time, rfneg_amp, seqtime, true);
			// rf magnitude
			double rfmaxamp = rfline[1];
			std::vector<double> rfshape = shapes[(int)rfline[2]-1];
			parse_shape_rf(samplingtime, rfmaxamp, rfdelay, rfshape, rf_time, rf_amp, seqtime, false);
		}
		// gradients
		if ((*block)[3] != 0) {
			std::vector<double> gxline = gradient_by_id((*block)[3], gradients);
			if (gxline.size() > 0) {
				parse_gradient(samplingtime, gxline, gx_time, gx_amp, seqtime);
			} else {
				gxline = gradient_by_id((*block)[3], traps);
				parse_trap(samplingtime, gxline, gx_time, gx_amp, seqtime);
			}
		}
		if ((*block)[4] != 0) {
			std::vector<double> gyline = gradient_by_id((*block)[4], gradients);
			if (gyline.size() > 0) {
				parse_gradient(samplingtime, gyline, gy_time, gy_amp, seqtime);
			} else {
				gyline = gradient_by_id((*block)[4], traps);
				parse_trap(samplingtime, gyline, gy_time, gy_amp, seqtime);
			}
		}
		if ((*block)[5] != 0) {
			std::vector<double> gzline = gradient_by_id((*block)[5], gradients);
			if (gzline.size() > 0) {
				parse_gradient(samplingtime, gzline, gz_time, gz_amp, seqtime);
			} else {
				gzline = gradient_by_id((*block)[5], traps);
				parse_trap(samplingtime, gzline, gz_time, gz_amp, seqtime);
			}
		}
		// adc
		if ((*block)[6] != 0) {
			std::vector<double> aline = adcs[(*block)[6]-1];
			parse_adc(samplingtime, aline, adc_time, adc_amp, seqtime);
		}
		// delays
		if ((*block)[1] != 0) {
			std::vector<double> dline = delays[(*block)[1]-1];
			seqtime += dline[1] * 1e-6;
		}
		// update sequence time
		if (rf_time.size() > 0) {
			seqtime = (rf_time.back() > seqtime) ? rf_time.back() : seqtime;
		}
		if (gx_time.size() > 0) {
			seqtime = (gx_time.back() > seqtime) ? gx_time.back() : seqtime;
		}
		if (gy_time.size() > 0) {
			seqtime = (gy_time.back() > seqtime) ? gy_time.back() : seqtime;
		}
		if (gz_time.size() > 0) {
			seqtime = (gz_time.back() > seqtime) ? gz_time.back() : seqtime;
		}
		if (adc_time.size() > 0) {
			seqtime = (adc_time.back() > seqtime) ? adc_time.back() : seqtime;
		}
	}
	// fix rf amplitude
	//rf_amplitude_by_neg(rfneg_time, rfneg_amp, rf_time, rf_amp);
}

// writes whole timecourse from stored memory object - dangerous when continuous readout is used
void old_write_timecourse(char *filename)
{
	std::cout << "MR simulation complete. Saving readout to: " << filename << std::endl;
	std::ofstream outfile;
    outfile.open(filename);
	outfile.precision(15);
	std::vector<std::vector<double>>::iterator ptr;
	for (ptr = readout_values.begin(); ptr < readout_values.end(); ptr++) {
		std::vector<double> roline = *ptr;
		std::vector<double>::iterator ptr2;
		for (ptr2 = roline.begin(); ptr2 < roline.end(); ptr2++) {
			outfile << *ptr2 << " ";
		}
		outfile << std::endl;
	}
	outfile.close();
}

// writes single readout timepoint - inefficient
void write_timepoint(char *filename, double t, double ro_x, double ro_y, double ro_z)
{
	std::ofstream outfile;
    outfile.open(filename);
	outfile.precision(15);
	outfile << t << " ";
	outfile << ro_x << " ";
	outfile << ro_y << " ";
	outfile << ro_z << std::endl;
	outfile.close();
}

// writes each frequency-encode readout line on completion - preferred method
void write_roline(std::string filename)
{
	std::cout << "- SMR: Writing readout line " << lines_read << " (length " << readout_values.size() << ") to " << filename << "." << std::endl;
	std::ofstream outfile;
    outfile.open(filename, std::ios_base::app);
	outfile.precision(15);
	std::vector<std::vector<double>>::iterator ptr;
	for (ptr = readout_values.begin(); ptr < readout_values.end(); ptr++) {
		std::vector<double> roline = *ptr;
		std::vector<double>::iterator ptr2;
		for (ptr2 = roline.begin(); ptr2 < roline.end(); ptr2++) {
			outfile << *ptr2 << " ";
		}
		outfile << std::endl;
	}
	outfile.close();
	readout_values.resize(0);
	lines_read++;
}

// placeholder to store readout filename in global variables
void write_timecourse(char *filename) {
	ro_filename = filename;
	if (curr_time_idx_adc > 0) write_roline(ro_filename);
}

double mag_at_time(double t, std::vector<double> &ch_time, std::vector<double> &ch_amp, double pos, int &curr_time_idx)
{
	double B = 0;
	if (ch_time.size() > 0) {
		// get new chunk if needed
		if (seqtype.compare("discrete") == 0) {
			if (seqchunk_idx >= seqchunk) {
				// reset indices
				seqchunks_used += 1;
				seqchunk_idx = 0;
				curr_time_idx = 0;
				curr_time_idx_rf = 0;
				curr_time_idx_rfn = 0;
				curr_time_idx_rfp = 0;
				curr_time_idx_gx = 0;
				curr_time_idx_gy = 0;
				curr_time_idx_gz = 0;
				curr_time_idx_adc = 0;
				// read in next chunk of sequence file
				std::ifstream seqfile;
				seqfile.open(seqfilename);
				use_discseq(seqfile, seqchunk, seqchunks_used, rf_time, rf_amp, rfneg_time, rfneg_amp, gx_time, gx_amp, gy_time, gy_amp, gz_time, gz_amp, adc_time, adc_amp);
				seqfile.close();
			}
			seqchunk_idx = 0;
		}
		// get magnetization values based on time/index
		for (auto it = ch_time.begin() + curr_time_idx; it != ch_time.end(); it++) {
			int idx = std::distance(ch_time.begin(), it);
			if (ch_time[idx] >= t) {
				curr_time_idx = idx;
				if (seqtype.compare("discrete") == 0) { // discrete sequence amplitudes are exact
					B += ch_amp[idx] * pos;
				} else if (seqtype.compare("pulseq") == 0) { // pulseq amplitudes are relative to gyromagnetic ratio
					B += ch_amp[idx] / (smrGyros[0]/6.28318530718) * pos;
				}
				break;
			}
		}
	}
	return B;
}

double phase_at_time(double t, std::vector<double> &ch_time, std::vector<double> &ch_amp, double pos, int &curr_time_idx)
{
	double phase = 0;
	if (ch_time.size() > 0) {
		// get phase value based on time/index
		for (auto it = ch_time.begin() + curr_time_idx; it != ch_time.end(); it++) {
			int idx = std::distance(ch_time.begin(), it);
			if (ch_time[idx] >= t) {
				curr_time_idx = idx;
				if (seqtype.compare("pulseq") == 0) { // pulseq amplitudes are relative to gyromagnetic ratio
					phase = ch_amp[idx];
				}
				break;
			}
		}
	}
	return phase;
}

double mag_at_time_global(double t, std::vector<double> &ch_time, std::vector<double> &ch_amp, int &curr_time_idx)
{
	double B = 0;
	if (ch_time.size() > 0) {
		// get new chunk if needed
		if (seqtype.compare("discrete") == 0) {
			if (seqchunk_idx >= seqchunk) {
				// reset indices
				seqchunks_used += 1;
				seqchunk_idx = 0;
				curr_time_idx = 0;
				curr_time_idx_rf = 0;
				curr_time_idx_rfn = 0;
				curr_time_idx_rfp = 0;
				curr_time_idx_gx = 0;
				curr_time_idx_gy = 0;
				curr_time_idx_gz = 0;
				curr_time_idx_adc = 0;
				// read in next chunk of sequence file
				std::ifstream seqfile;
				seqfile.open(seqfilename);
				use_discseq(seqfile, seqchunk, seqchunks_used, rf_time, rf_amp, rfneg_time, rfneg_amp, gx_time, gx_amp, gy_time, gy_amp, gz_time, gz_amp, adc_time, adc_amp);
				seqfile.close();
			}
			seqchunk_idx = 0;
		}
		// get magnetization values based on time/index
		for (auto it = ch_time.begin() + curr_time_idx; it != ch_time.end(); it++) {
			int idx = std::distance(ch_time.begin(), it);
			if (ch_time[idx] >= t) {
				curr_time_idx = idx;
				if (seqtype.compare("discrete") == 0) { // discrete sequence amplitudes are exact
					B += ch_amp[idx];
				} else if (seqtype.compare("pulseq") == 0) { // pulseq amplitudes are relative to gyromagnetic ratio
					B += ch_amp[idx] / (smrGyros[0]/6.28318530718);
				}
				break;
			}
		}
	}
	return B;
}

double adc_at_time(double t, std::vector<double> &ch_time, std::vector<double> &ch_amp, int &curr_time_idx)
{
	double adc_ampa;
	if (ch_time.size() > 0) {
		for (auto it = ch_time.begin() + curr_time_idx; it != ch_time.end(); it++) {
			int idx = std::distance(ch_time.begin(), it);
			if (ch_time[idx] >= t) {
				curr_time_idx = idx;
				adc_ampa = ch_amp[idx];
				break;
			}
		}
	}
	return adc_ampa;
}

// parseq
void parseq(char *line2)
{
	smr_init();
	// parse command line
	const char s[2] = " ";
	char *token;
	token = strtok(line2, s);
	char *filename;
	int i = 0;
	while (token != NULL) {
		if (i == 0) { // sequence file
			seqfilename = token;
			filename = token;
		} else if (i == 1) { // sequence type
			seqtypetok = token;
			seqtype.assign(seqtypetok);
		} else if (i == 2) { // chunk size
			seqchunk = strtol(token, NULL, 10);
		}
		token = strtok(NULL, s);
		i += 1;
	}
	// read in seq file
	std::ifstream seqfile;
    seqfile.open(filename);
	if (seqtype.compare("discrete") == 0) {
		std::cout << "- Pulse sequence (" << seqtype << " timecourse): " << filename << std::endl;
		use_discseq(seqfile, seqchunk, seqchunks_used, rf_time, rf_amp, rfneg_time, rfneg_amp, gx_time, gx_amp, gy_time, gy_amp, gz_time, gz_amp, adc_time, adc_amp);
	} else if (seqtype.compare("pulseq") == 0) {
		std::cout << "- Pulse sequence (" << seqtype << "): " << filename << std::endl;
		read_pulseq(seqfile, blocks, delays, rfs, gradients, traps, adcs, shapes);
	}
	seqfile.close();
	// generate timecourse
	if (seqtype.compare("pulseq") == 0) {
		gen_timecourse(samplingtime, blocks, delays, rfs, traps, adcs, shapes, rf_time, rf_amp, rfneg_time, rfneg_amp, rfp_time, rfp_amp, gx_time, gx_amp, gy_time, gy_amp, gz_time, gz_amp, adc_time, adc_amp);
	}
}

// setparams
void smrparseparams(char *filename)
{
	std::cout << filename << std::endl;
}

// timestep function called in Smoldyn
void smr_timestep(double t, double tau) {
	smr_init();
	double adc_ampa = adc_at_time(t, adc_time, adc_amp, curr_time_idx_adc);
	ro_mx = 0;
	ro_my = 0;
	ro_mz = 0;
	double rfa = mag_at_time(t, rf_time, rf_amp, 1, curr_time_idx_rf);
	double rfn = mag_at_time(t, rfneg_time, rfneg_amp, 1, curr_time_idx_rfn);
	if (rfn > 0) {
		rfa *= -1;
	}
	double rfp = phase_at_time(t, rfp_time, rfp_amp, 1, curr_time_idx_rfp);
	std::vector<double> Beff = { rfa*sin(rfp), rfa*cos(rfp), 0 }; // adjusted for phase cycling
	std::vector<double> Grads = { 0, 0, 0 };
	Grads[0] = mag_at_time_global(t, gx_time, gx_amp, curr_time_idx_gx);
	Grads[1] = mag_at_time_global(t, gy_time, gy_amp, curr_time_idx_gy);
	Grads[2] = mag_at_time_global(t, gz_time, gz_amp, curr_time_idx_gz);
	// adjust base polarizations for decline in hyperpolarized magnetization
	for (int i = 0; i < smrBasePols.size(); i++) {
		if (smrBasePols[i] > 1 & smrHPT1s[i] > 0) smrBasePols[i] *= exp(-tau/smrHPT1s[i]);
		if (smrBasePols[i] < 1) smrBasePols[i] = 1;
		if (abs(rfa) > 0) relaxing_times[i] = 0.;
		else if (smrBasePols[i] == 1) relaxing_times[i] += tau;
	}
	// forward Bloch rotation based on local magnetic field for all MR particles
	//#pragma omp parallel for private(Beff,Grads,tau) reduction(+:ro_mx,ro_my,ro_mz)
	for (int i = 0; i < smrblocks.size(); i++) {
		if (smrblocks[i].Mz > 1 & smrblocks[i].Mz < smrBasePols[smrblocks[i].spinspecies-1]) smrBasePols[smrblocks[i].spinspecies-1] = smrblocks[i].Mz*1;
		if (t < 1e-12 | smrblocks[i].Mz > smrBasePols[smrblocks[i].spinspecies-1]) smrblocks[i].Mz = smrBasePols[smrblocks[i].spinspecies-1];
		double gyromag = smrGyros[smrblocks[i].spinspecies-1] + smrCSs[smrblocks[i].spinspecies-1];
		if (gyromag < 1e-3) continue;
		double posx = smrblocks[i].smolmptr->pos[0];
		double posy = smrblocks[i].smolmptr->pos[1];
		double posz = smrblocks[i].smolmptr->pos[2];
		double Boffres = (gyromag - 42.57638474*6.28318530718e6) / (42.57638474*6.28318530718e6) * 3; // correct for resonance deviation from rotating frame
		Beff[2] = Grads[0]*posx + Grads[1]*posy + Grads[2]*posz + Boffres;
		if (abs(Beff[0]) > 0 | abs(Beff[1]) > 0 | abs(Beff[2]) > 0) { // precession in the rotating frame
			rotquat(gyromag, tau, smrblocks[i].Mx, smrblocks[i].My, smrblocks[i].Mz, Beff[0], Beff[1], Beff[2]);
		}
		if (abs(rfa) < 1e-12) { // relaxation when there's no excitation
			smrblocks[i].T1 = get_T1(posx, posy, posz, smrblocks[i].spinspecies);
			smrblocks[i].T2 = get_T2(posx, posy, posz, smrblocks[i].spinspecies);
			smr_relax(tau, smrblocks[i].T1, smrblocks[i].T2, smrHPT1s[smrblocks[i].spinspecies-1], smrblocks[i].M0, smrblocks[i].Mx, smrblocks[i].My, smrblocks[i].Mz, relaxing_times[smrblocks[i].spinspecies-1]);
		} else {
			smrblocks[i].M0 = smrblocks[i].Mz;
		}
		ro_mx += smrblocks[i].Mx;
		ro_my += smrblocks[i].My;
		ro_mz += smrblocks[i].Mz;
	}
	// readout
	if (adc_timings.size() > 0) {
		if (abs(t-adc_timings[idx_adc]) < samplingtime/2) {
			//std::vector<double> ro = { t, 0, ro_mx*sin(rfp) + ro_my*cos(rfp), ro_mz }; // phase cycling - readout only to y
			rotquat_hardangle(ro_rfp, ro_mx, ro_my, ro_mz); // phase cycling
			std::vector<double> ro = { t, ro_mx, ro_my, ro_mz }; // phase cycling
			readout_values.push_back(ro);
			idx_adc += 1;
		}
	} else if (adc_ampa > 0) {
		rotquat_hardangle(ro_rfp, ro_mx, ro_my, ro_mz); // phase cycling
		std::vector<double> ro = { t, ro_mx, ro_my, ro_mz }; // phase cycling
		readout_values.push_back(ro);
		stored_rfp = rfp;
		//write_roline("buffer.txt", ro[0], ro[1], ro[2], ro[3]);
	} else if (adc_ampa <= 0 & readout_values.size() > 0) {
		write_roline(ro_filename);
		ro_rfp = stored_rfp;
	}
	// output debug information
	if (smrdebug_new) { 
		if (debug_idx >= debugsamplefactor) {
			debugfile << t << " ";
			debugfile << rfa << " ";
			debugfile << rfn << " ";
			debugfile << rfp << " ";
			debugfile << Grads[0] << " ";
			debugfile << Grads[1] << " ";
			debugfile << Grads[2] << " ";
			debugfile << adc_ampa << " ";
			debugfile << ro_mx << " ";
			debugfile << ro_my << " ";
			debugfile << ro_mz << "\n";
			debug_idx = 0;
		}
		debug_idx += 1;
	}
	// output k-space trajectory
	if (calckspace) {
		kx += mag_at_time(t, gx_time, gx_amp, 1, curr_time_idx_gx) + rfa*sin(rfp);
		ky += mag_at_time(t, gy_time, gy_amp, 1, curr_time_idx_gy) + rfa*cos(rfp);
		kz += mag_at_time(t, gz_time, gz_amp, 1, curr_time_idx_gz);
		if (kspace_idx >= kspacesamplefactor) {
			kspacefile << t << " ";
			kspacefile << kx << " ";
			kspacefile << ky << " ";
			kspacefile << kz << "\n";
			kspace_idx = 0;
		}
		kspace_idx += 1;
	}
}